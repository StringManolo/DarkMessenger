#!/usr/bin/env node

import fs from "fs";
import { spawn, exec } from "child_process";
import parseCLI from "simpleargumentsparser";
import chalk from "chalk";

// globals
let v = false; // verbose
let d = false; // debug
let config;     // config

(async () => {
  const cli = await parseCLI();

  if (cli.noArgs || cli.s.h || cli.c.help)
    exit(`usage:

start     wakeup all services
stop      shutdown all services

add [alias] [domain.onion]                Add an address to your Address Book
addme [domain.onion]                      Tell remote server to add you
contacts [alias or none]                   Show a contact address or all contacts
send [alias] [message]                    Send a message 
show [alias or none]                      Show messages from someone 
delete [id]                               Delete messages from someone 


-c --config <filename>
-v --verbose
-d --debug
`);

  if (cli.s.v || cli.c.verbose) v = true;

  if (cli.c.start || cli.o[0].includes("start")) {
    await start(cli);
  } else if (cli.c.stop || cli.o[0].includes("stop")) {
    await stop(cli);
  } else {
    if (cli.o[0].includes("add")) {
      await add(cli);
    } else if (cli.o[0].includes("addme")) {
      await addme(cli);
    } else if (cli.o[0].includes("contacts")) {
      await contacts();
    } else if (cli.o[0].includes("send")) {
      await send(cli);
    } else if (cli.o[0].includes("show")) {
      await show(cli);
    } else if (cli.o[0].includes("delete")) {
      await del(cli);
    } else {
      // TODO: not known commands
    }
  }
})();

const exit = msg => {
  console.log(msg);
  process.exit(0);
};

const verbose = msg => {
  if (v || config?.verbose) {
    console.log(`${chalk.green("[VERBOSE]")} ${msg}`);
  }
};

const debug = msg => {
  if (d || config?.debug) {
    if (config?.debug_with_time) {
      const now = new Date();
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const seconds = now.getSeconds().toString().padStart(2, '0');
      const milliseconds = now.getMilliseconds().toString().padStart(3, '0');
      const timestamp = `${hours}:${minutes}:${seconds}.${milliseconds}`;
      console.log(`${chalk.blue("[DEBUG-" + timestamp + "]")} ${msg}`);
    } else {
      console.log(`${chalk.blue("[DEBUG]")} ${msg}`);
    }
  }
};

const error = msg => {
  console.log(`${chalk.red("[ERROR]")} ${msg}`);
};

const sleep = ms => {
  return new Promise(resolve => setTimeout(resolve, ms));
}


const curl = async (url, args) => {
  return new Promise((resolve, reject) => {
    debug(`Running command: curl --socks5-hostname 127.0.0.1:9050 '${url}:9001/${args}' `);
    exec(`curl --socks5-hostname 127.0.0.1:9050 ${url}:9001/${args}`, (err, stdout, stderr) => {
      if (err) {
        error(`Error running curl: ${err}`);
        reject(err);
        return;
      }
      
      /*if (stderr) {
        error(`stderr: ${stderr}`);
      }*/

      debug(`Resolving command ...`);
      resolve(stdout);
    });
  });
};

const add = async (cli) => {
  v = true;
  d = true;
  debug(`Getting alias and address from cli args ...`);
  const alias = cli.o?.[1]?.[0];
  const address = cli.o?.[2]?.[0];
  debug(`Alias: (${alias}), Address (${address})`);


  let addressBook = [];
  try {
    debug(`Reading ./address_book/list.txt ... `);
    const data = await fs.promises.readFile('./address_book/list.txt', 'utf8');
    debug(`Splitting entries by line ... `);
    addressBook = data.split('\n').map(line => line.trim()).filter(line => line !== '');
    debug(`A total of ${addressBook.length} contacts found in your addresses list`);
  } catch (err) {
    error('Error reading file:', err);
    process.exit(0);
  }

  debug(`Adding new entry to in-memory address book ... `);
  addressBook.push(`${alias} ${address}`);
  debug(`Removing all duplicates (if there is any) ... `);
  const uniqueEntries = new Set(addressBook);
  debug(`Casting addressBook array to a string (ready to dump in file)... `);
  const updatedText = Array.from(uniqueEntries).join('\n');

  try {
    debug(`Rewrite address_book/list.txt with the new ssv alias address pair`);
    await fs.promises.writeFile('./address_book/list.txt', updatedText);
    console.log("Added to your address book");
  } catch (err) {
    error(`Error writting on the address book: ${err}`);
  } 
  debug(`Done`);
}

const addme = async (cli) => { //TODO: Add Verbose and Debug outputs
  v = true;
  d = true;
  try {
    debug(`Loading config...`);
    config = await loadConfig("./config/dark-messenger.json");
    debug(`Loading hostname...`);
    const hostname = config.hidden_service_hostname = (await loadFile("./hidden_service/hostname")).trim();
    debug(`Extracting onion domain from cli`);
    if (! cli.o?.[1]?.[0] ) {
      error(`Use "./DarkMessenger addme domain.onion" to provide the address of the user you want to add you`);
      process.exit(0);
    }

    const result = await curl(`http://${cli.o[1][0]}`, `addme -d '{ "alias":"${config.username}", "address":"${hostname}" }' -H 'Content-Type: application/json'`);
    debug(`Result: ${result}`);
  } catch(err) {
    error(`Error on Add() : ${err}`);
  }
}

const send = async (cli) => {
  v = true;
  d = true;
  const alias = cli.o?.[1]?.[0];
  const message = cli.o?.[2]?.[0];
  let address = "";
  try {
    const data = await fs.promises.readFile('./address_book/list.txt', 'utf8');
    const addressBook = data.split('\n').map(line => line.trim()).filter(line => line !== '');
    for (let i in addressBook) {
      if (addressBook[i].split(" ")[0] == alias) {
        debug(`Alias found, extracting address ... `);
        address = addressBook[i].split(" ")[1];
        break;
      }
    }

    debug(`Loading config...`);
    config = await loadConfig("./config/dark-messenger.json");

    debug(`Sending message ... `);
    const result = await curl(`http://${address}`, `send -d '{ "from":"${config.username}", "message":"${Buffer.from(message).toString('base64')}" }' -H 'Content-Type: application/json'`);
    console.log(result); 

  } catch(err) {
    error(`Error on Add() : ${err}`);
  }
}


const contacts = async (cli) => {

}


const show = async (cli) => {
  v = true;
  d = true;

  const alias = cli.o?.[1]?.[0];
  debug(`Alias on show function is ${alias}`);
  
  const messagesRAW = await fs.promises.readFile('./messages/list.json', 'utf8'); 
  const messages = JSON.parse(messagesRAW);

  let textMessages = "";
  let found = false;

  if (!alias) {
    for (let i in messages) {
      found = true;
      textMessages += `Message with id ${chalk.yellow(messages[i].id)} from ${chalk.yellow(messages[i].from)}\n`
      textMessages += `${messages[i].message}\n\n`;
    }
  } else {
    for (let i in messages) {
      if (messages[i].from === alias) {
         found = true;
         textMessages += `Message with id ${chalk.yellow(messages[i].id)} from ${chalk.yellow(messages[i].from)}\n${messages[i].message}\n\n`; 
      }
    }
  }
  
  if (!found) {
    console.log(`No messages to show`);
  } else {
    console.log(textMessages);
  }
}

const del = async (cli) => {
  v = true;
  d = true;

  const id = cli.o?.[1]?.[0];
  if (!id) {
    error(`You need to provide the id of the message you want to remove`);
  }
}


const startTor = () => {
  debug(`Creating file to store tor pid process ... `);
  verbose(`Starting Tor ...`);
  const process = spawn("/usr/bin/tor", ["-f", "./config/torrc.conf"], {
    detached: true,
    stdio: "ignore"
  });

  debug(`Storing tor pid at ./tor_files/tor.pid ...`);
  fs.writeFileSync("./tor_files/tor.pid", process.pid.toString());

  debug(`Detaching tor process from node process ...`);
  process.unref();

  process.on('error', (err) => {
    error(`Error Starting Tor: ${err}`);
  });

  process.on("close", (code) => {
    verbose(`Closing Tor ...`);
    debug(`Tor process closing with code: ${code}`);
  });
};

const stopTor = () => {
  debug(`Extracting tor process id from ./tor_files/tor.pid ... `);
  if (fs.existsSync("./tor_files/tor.pid")) {
    const pid = parseInt(fs.readFileSync("./tor_files/tor.pid").toString(), 10);
    debug(`Extracted pid: ${pid}`);

    try {
      verbose(`Stopping Tor`);
      debug(`Sending SIGTERM signal tor process id ${pid}`);
      process.kill(pid, 'SIGTERM');
      console.log("Tor successfully stopped.");
      debug(`Deleting ./tor_files/tor.pid file ...`);
      fs.unlinkSync("./tor_files/tor.pid");
      debug(`./tor_files/tor.pid has been deleted`);
    } catch (err) {
      error(`Unable to terminate tor process with PID ${pid}: ${err}`);
    }
  } else {
    error(`./tor_files/tor.pid can't be found`);
  }
};

const start = async (cli) => {
  if (cli.c.config) {
    if (typeof cli.c.config === "string") {
      config = await loadConfig(cli.c.config);
    }
  }

  if (!config) {
    console.log(`Loading default config file expected at (./config/dark-messenger.json) ... `);
    config = await loadConfig("./config/dark-messenger.json");
    if (!config) {
      exit(`Unable to load any config.`);
    }
  }

  verbose("Verbose Activated");
  debug("Debug Activated");

  startTor();

  if (config) {
    debug(`Replacing auto by hostnane ...`);
    if (config?.hidden_service_hostname === "auto") {
      let secondsCounter = 0;
      debug(`Waiting for ./hidden_service/hostname file to be created by tor`);
      while (!fs.existsSync("./hidden_service/hostname")) {
        await sleep(1000);
        debug(`Waited ${++secondsCounter} second/s for file to be created by Tor`);
        if (secondsCounter > 5) {
          debug(`Waiting for to long. Breaking from loop`);
        }
      }

      try {
        config.hidden_service_hostname = (await loadFile("./hidden_service/hostname")).trim();
        debug(`Got hostname: ${config.hidden_service_hostname}`);
      } catch(err) {
        error(`Unable to load ./hidden_service/hostanme, maybe try again: ${error}`);
      }
    }

    debug(`Checking if use_web_gui is true`);
    if (config?.use_web_gui) {
      debug(`Generating GUI Server source code ...`);
      const guiServerScript = generateGuiServerScript(config);
      debug(`GUI Server code generated:\n${guiServerScript}\n`);
      debug(`Creating ./startGuiServer.js file ...`);
      await writeGuiServerScript(guiServerScript);
      debug(`Calling startGuiServer() ...`);
      startGuiServer();
      debug(`Call done`);
    } else {
      debug(`Not using Web GUI, to activate it add next options to your ./config/dark-messenger.json file:\n"use_web_gui": "true",\n"web_gui_address": "127.0.0.1",\n"web_gui_port": "9000",`);
    }

    debug(`Generating Hidden Server source code ...`);
    const hiddenServerScript = generateHiddenServerScript(config);
    debug(`Hidden Server code generated:\n${hiddenServerScript}\n`);
    debug(`Creating ./startHiddenServer.js file ...`);
    await writeHiddenServerScript(hiddenServerScript);
    debug(`Calling startHiddenServer() ...`);
    startHiddenServer();
    debug(`Call done`);

  } else {
    debug(`Config not found. This is can't never happen btw`);
  }

};

const stop = async (cli) => {
  if (cli.c.config) {
    if (typeof cli.c.config === "string") {
      config = await loadConfig(cli.c.config);
    }
  }

  if (!config) {
    console.log(`Loading default config file expected at (./config/dark-messenger.json) ... `);
    config = await loadConfig("./config/dark-messenger.json");
    if (!config) {
      exit(`Unable to load any config.`);
    }
  }

  verbose("Verbose Activated");
  debug("Debug Activated");

  console.log(`Stopping All Services...`);
  stopGuiServer();
  stopHiddenServer();
  stopTor();
};

const loadFile = async (path) => {
  try {
    const data = await fs.promises.readFile(path, "utf8");
    return data;
  } catch (err) {
    error(`Unable to read ${path}: ${err}`)
    throw err;
  }
};

const loadConfig = async (path) => {
  try {
    const file = await loadFile(path);
    return JSON.parse(file);
  } catch (err) {
    error(`Unable to load config ${path} as JSON: ${err}`)
  }
};

const generateGuiServerScript = (config) => {
  const script = `#!/usr/bin/env node
    import fs from "fs";
    import express from "express";

    const app = express();
    const port = ${config?.web_gui_port || 9000};
    const hostname = "${config?.web_gui_address || "127.0.0.1"}";

    app.get('/', (req, res) => {
      res.send(\`<!DOCTYPE html>
<html lang="en">
<head prefix="og:http://ogp.me/ns#">
  <meta charset="utf-8">
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <title>Dark Messenger GUI</title>
  <meta property="og:type" content="website">
  <meta name="theme-color" content="#ffffff">
  <style>
    body {
      margin: 0;
      padding: 0;
    }
    body {
      background-color: black;
      color: snow;
    }
  </style>
</head>
<body>
  <h1>Dark Messenger</h1>
  <button onclick="sendMessage()">Send msg</button>
  <script>
    function showAlert(message) {
      alert(message);
    }

    function sendMessage() {
      const message = 'test123';

      fetch('${config?.http_tor_proxy_url || "http://127.0.0.1:9002/"}http://${config?.hidden_service_hostname || "127.0.0.1"}:${config?.hidden_service_port || 9001}', {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain'
        },
        body: message
      })
      .then(response => response.text())
      .then(data => showAlert('Resp: ' + data))
      .catch(error => showAlert('Error: ' + error.message));                                }
  </script>
</body>
</html>
    \`);
    });

    const server = app.listen(port, hostname, () => {
      console.log('GUI Server listening at http://\${hostname}:\${port}');
      fs.writeFileSync('./gui_server.pid', process.pid.toString());
    });

    process.on('SIGTERM', () => {
      console.log('Received SIGTERM. Closing GUI Server...');
      server.close(() => {
        console.log('GUI Server closed.');
        fs.unlinkSync('./gui_server.pid');
        console.log('gui_server.pid has been deleted.');
      });
    });
  `;

  return script.trim();
};

const writeGuiServerScript = async (scriptContent) => {
  try {
    await fs.promises.writeFile('./startGuiServer.js', scriptContent);
    verbose('startGuiServer.js file has been created successfully.');
  } catch (err) {
    error(`Failed to write startGuiServer.js: ${err}`);
  }
};

const startGuiServer = () => {
  debug(`Running chmod 775 over ./startGuiServer.js ... `);
  fs.chmod("./startGuiServer.js", 0o775, (err) => {
    if (err) {
      error(`CRITICAL: Error running chmod 775 over ./startGuiServer.js: ${err}`);
      exit();
    }
    debug(`./startGuiServer.js is now executable`);
  });

  verbose(`Starting GUI Server ...`);
  const process = spawn("./startGuiServer.js", [], {
    detached: true,
    stdio: "ignore"
  });

  debug(`Detaching GUI Server process from node process ...`);
  process.unref();

  process.on('error', (err) => {
    error(`Error Starting GUI Server: ${err}`);
  });

  process.on("close", (code) => {
    verbose(`Closing GUI Server ...`);
    debug(`GUI Server process closing with code: ${code}`);
  });
};

const stopGuiServer = () => {
  debug(`Extracting GUI server process id from ./gui_server.pid ... `);
  if (fs.existsSync("./gui_server.pid")) {
    const pid = +fs.readFileSync("./gui_server.pid").toString();
    debug(`Extracted pid: ${pid}`);

    try {
      verbose(`Stopping GUI Server`);
      debug(`Sending SIGTERM signal to GUI server process id ${pid}`);
      process.kill(pid, 'SIGTERM');
      console.log("GUI Server successfully stopped.");
      debug(`Deleting ./gui_server.pid file ...`);
      fs.unlinkSync("./gui_server.pid");
      debug(`./gui_server.pid has been deleted`);
      debug("Deleting ./startGuiServer.js ...");
      fs.unlinkSync("./startGuiServer.js");
      debug("./startGuiServer.js has been deleted");
    } catch (err) {
      error(`Unable to terminate GUI server process with PID ${pid}: ${err}`);
    }
  } else {
    error(`./gui_server.pid can't be found`);
  }
};




const generateHiddenServerScript = (config) => {
  const script = `#!/usr/bin/env node
    import fs from "fs";
    import express from "express";

    const app = express();
    const port = ${config?.hidden_service_port || 9001};
    const address = "${config?.hidden_service_address || "127.0.0.1"}";

    app.use(express.json());

    app.get("/", (req, res) => {
      res.send("DarkMessenger API");
    });

    /* Req Example:
     * curl --socks5-hostname 127.0.0.1:9050 http://4akbfdpst32zjwel776hf4ljggdirzopovkgzss74x2h4nxbwsfj7xid.onion:9001/addme -d '{ "alias": "sm", "address": "sm.onion" }' -H "Content-Type: application/json"
    */
    app.post('/addme', async (req, res) => {
      const { alias, address } = req.body;
      let addressBook = [];
      try {
        const data = await fs.promises.readFile('./address_book/list.txt', 'utf8');
        addressBook = data.split('\\n').map(line => line.trim()).filter(line => line !== '');
      } catch (err) {
        console.error('Error reading file:', err);
        return res.status(500).send('Internal Error reading address book');
      }

      addressBook.push(\`\${alias} \${address}\`);
      const uniqueEntries = new Set(addressBook);
       
      const updatedText = Array.from(uniqueEntries).join('\\n');

      try {
        await fs.promises.writeFile('./address_book/list.txt', updatedText);
        res.status(200).send("Remote server added you to it's address book");
      } catch (err) {
        return res.status(500).send('Internal Server Error writting address book');
      }

    });


    app.post('/send', async (req, res) => {
      try {
        const { from, message } = req.body;
        const decodedMessage = Buffer.from(message, 'base64').toString('utf-8');
        const msg = {}; 
        msg.from = from;
        msg.message = decodedMessage;

        const existingMessages = JSON.parse(await fs.promises.readFile('./messages/list.json', 'utf8')); 

        existingMessages.push(msg);

        // Add an id to handle the messages (read, delete, answer)
        for (let i = 0; i < existingMessages.length; ++i) {
          existingMessages[i].id = i;
        }

        await fs.promises.writeFile('./messages/list.json', JSON.stringify(existingMessages, null, 2));
        res.status(200).send('Message saved');
      } catch(err) {
        res.status(500).send('Internal Server Error read/write operation at ./messages/list.json');
      }
    });


    const server = app.listen(port, address, () => {
      console.log(\`Hidden Server listening at http://\${address}:\${port}\`);
      fs.writeFileSync('./hidden_server.pid', process.pid.toString());
    });

    process.on('SIGTERM', () => {
      console.log('Received SIGTERM. Closing GUI Server...');
      server.close(() => {
        console.log('GUI Server closed.');
        fs.unlinkSync('./hidden_server.pid');
        console.log('hidden_server.pid has been deleted.');
      });
    });
  `;

  return script.trim();
};

const writeHiddenServerScript = async (scriptContent) => {
  try {
    await fs.promises.writeFile('./startHiddenServer.js', scriptContent);
    verbose('startHiddenServer.js file has been created successfully.');
  } catch (err) {
    error(`Failed to write startHiddenServer.js: ${err}`);
  }
};

const startHiddenServer = () => {
  debug(`Running chmod 775 over ./startHiddenServer.js ... `);
  fs.chmod("./startHiddenServer.js", 0o775, (err) => {
    if (err) {
      error(`CRITICAL: Error running chmod 775 over ./startHiddenServer.js: ${err}`);
      exit();
    }
    debug(`./startHiddenServer.js is now executable`);
  });

  verbose(`Starting Hidden Server ...`);
  const process = spawn("./startHiddenServer.js", [], {
    detached: true,
    stdio: "ignore"
  });

  debug(`Detaching Hidden Server process from node process ...`);
  process.unref();

  process.on('error', (err) => {
    error(`Error Starting Hidden Server: ${err}`);
  });

  process.on("close", (code) => {
    verbose(`Closing Hidden Server ...`);
    debug(`Hidden Server process closing with code: ${code}`);
  });
};

const stopHiddenServer = () => {
  debug(`Extracting Hidden server process id from ./hidden_server.pid ... `);
  if (fs.existsSync("./hidden_server.pid")) {
    const pid = +fs.readFileSync("./hidden_server.pid").toString();
    debug(`Extracted pid: ${pid}`);

    try {
      verbose(`Stopping Hidden Server`);
      debug(`Sending SIGTERM signal to Hidden server process id ${pid}`);
      process.kill(pid, 'SIGTERM');
      console.log("Hidden Server successfully stopped.");
      debug(`Deleting ./hidden_server.pid file ...`);
      fs.unlinkSync("./hidden_server.pid");
      debug(`./hidden_server.pid has been deleted`);
      debug("Deleting ./startHiddenServer.js ...");
      fs.unlinkSync("./startHiddenServer.js");
      debug("./startHiddenServer.js has been deleted");
    } catch (err) {
      error(`Unable to terminate Hidden server process with PID ${pid}: ${err}`);
    }
  } else {
    error(`./hidden_server.pid can't be found`);
  }
};
